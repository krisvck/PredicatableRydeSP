'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schema = _joi2.default.object().keys({
  api_key: _joi2.default.string().description('Your openrouteservice API key'),
  coordinates: _joi2.default.array().min(2).max(50).items(_joi2.default.array().length(2).items(_joi2.default.number()).required()).required().description('The coordinates tuple the route should be calculated from. In order of visit'),
  profile: _joi2.default.string().valid(['driving-car', 'driving-hgv', 'foot-walking', 'foot-hiking', 'cycling-regular', 'cycling-road', 'cycling-mountain', 'cycling-electric', 'wheelchair']).default('driving-car').description('Specifies the mode of transport to use when calculating directions.'),
  restrictions: _joi2.default.object().when('profile', {
    is: _joi2.default.string().regex(/^driving-hgv$/),
    then: _joi2.default.object().keys({
      length: _joi2.default.number().description('Length of the HGV vehicle'),
      width: _joi2.default.number().description('Width of the HGV vehicle'),
      weight: _joi2.default.number().description('Weight of the HGV vehicle'),
      height: _joi2.default.number().description('Height of the HGV vehicle'),
      axleload: _joi2.default.number().description('Axleload of the HGV vehicle'),
      hazmat: _joi2.default.boolean().description('Whether the HGV carries hazardous materials')
    })
  }).when('profile', {
    is: _joi2.default.string().regex(/^wheelchair$/),
    then: _joi2.default.object().keys({
      surface_type: _joi2.default.any().description('Surface type'),
      track_type: _joi2.default.any().description('Track type'),
      smoothness_type: _joi2.default.any().description('Smoothness type'),
      maximum_sloped_curb: _joi2.default.any().description('Maximum sloped curb'),
      maximum_incline: _joi2.default.any().description('Maximum incline')
    })
  }).when('profile', {
    is: _joi2.default.string().regex(/^driving-car$/),
    then: _joi2.default.object().keys({})
  }).when('profile', {
    is: _joi2.default.string().regex(/^cycling.*/),
    then: _joi2.default.object().keys({})
  }).when('profile', {
    is: _joi2.default.string().regex(/^foot.*/),
    then: _joi2.default.object().keys({})
  }),
  avoidables: _joi2.default.array().when('profile', {
    is: _joi2.default.string().regex(/^driving.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['highways', 'tollways', 'ferries', 'fords'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^foot.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['steps', 'ferries', 'fords'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^cycling.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['highways', 'tollways', 'ferries'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^wheelchair.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['steps', 'ferries'])).description('Valid avoidables for selected profile.')
  }).description('List of supported avoidables for specific profile.'),
  avoid_polygons: _joi2.default.object(),
  preference: _joi2.default.string().valid(['fastest', 'shortest', 'recommended']).default('fastest').description('Specifies the routing preference.'),
  units: _joi2.default.string().valid(['m', 'km', 'mi']).default('m').description('Specifies the units of response.'),
  language: _joi2.default.string().valid(['en', 'de', 'cn', 'es', 'ru', 'dk', 'fr', 'it', 'nl', 'br', 'se', 'tr', 'gr']).default('en').description('Language for routing instructions.'),
  geometry: _joi2.default.boolean().default(true).description('Specifies whether geometry should be returned.'),
  geometry_format: _joi2.default.string().valid(['encodedpolyline', 'geojson', 'polyline']).description('Specifies which geometry format should be returned.'),
  format: _joi2.default.string().valid(['json', 'geojson', 'gpx']).default('json').description('Specifies the format of response.'),
  instructions: _joi2.default.boolean().default(true).description('Specifies whether route instruction should be returned.'),
  instructions_format: _joi2.default.string().valid(['text', 'html']).default('text').description('Specifies the format of route instructions.'),
  roundabout_exits: _joi2.default.boolean(),
  attributes: _joi2.default.array().items(_joi2.default.string().valid('avgspeed', 'detourfactor', 'percentage')).description('Returns route attributes.'),
  continue_straight: _joi2.default.boolean(),
  elevation: _joi2.default.boolean().description('Specifies whether to return elevation values for points.'),
  extra_info: _joi2.default.array().items(_joi2.default.string().valid('steepness', 'suitability', 'surface', 'waycategory', 'waytype', 'tollways', 'traildifficulty')).description('Returns additional information'),
  optimized: _joi2.default.boolean(),
  options: _joi2.default.object().description('Refer to https://openrouteservice.org for detailed documentation. Construct your own dict() following the example of the minified options object. Will be converted to json automatically.'),
  service: _joi2.default.string().default('directions').description('Determines the service endpoint to be used.'),
  api_version: _joi2.default.string().valid(['v2']).default('v2').description('Determines the API version to be used.'),
  host: _joi2.default.string().default('https://api.openrouteservice.org').description('Determines the API url.'),
  mime_type: _joi2.default.string().valid(['application/json', 'application/geo+json']).default('application/json').description('Determines the mime type of request.')
}).unknown(false);

exports.default = schema;