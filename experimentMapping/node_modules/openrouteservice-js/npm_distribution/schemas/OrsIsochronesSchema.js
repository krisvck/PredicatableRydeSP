'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _joi = require('joi');

var _joi2 = _interopRequireDefault(_joi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var schema = _joi2.default.object().keys({
  api_key: _joi2.default.string().description('Your openrouteservice API key'),
  locations: _joi2.default.array().min(1).max(5).items(_joi2.default.array().length(2).required()).required().description('Isochrones locations to use in the request.'),
  profile: _joi2.default.string().valid(['driving-car', 'driving-hgv', 'foot-walking', 'foot-hiking', 'cycling-regular', 'cycling-road', 'cycling-mountain', 'cycling-electric', 'wheelchair']).default('driving-car').description('Specifies the mode of transport to use when calculating directions.'),
  restrictions: _joi2.default.object().when('profile', {
    is: _joi2.default.string().regex(/^driving-hgv$/),
    then: _joi2.default.object().keys({
      length: _joi2.default.number().description('Length of the HGV vehicle'),
      width: _joi2.default.number().description('Width of the HGV vehicle'),
      weight: _joi2.default.number().description('Weight of the HGV vehicle'),
      height: _joi2.default.number().description('Height of the HGV vehicle'),
      axleload: _joi2.default.number().description('Axleload of the HGV vehicle'),
      hazmat: _joi2.default.boolean().description('Whether the HGV carries hazardous materials')
    })
  }).when('profile', {
    is: _joi2.default.string().regex(/^wheelchair$/),
    then: _joi2.default.object().keys({
      surface_type: _joi2.default.any().description('Surface type'),
      track_type: _joi2.default.any().description('Track type'),
      smoothness_type: _joi2.default.any().description('Smoothness type'),
      maximum_sloped_curb: _joi2.default.any().description('Maximum sloped curb'),
      maximum_incline: _joi2.default.any().description('Maximum incline')
    })
  }).when('profile', {
    is: _joi2.default.string().regex(/^driving-car$/),
    then: _joi2.default.object().keys({})
  }).when('profile', {
    is: _joi2.default.string().regex(/^cycling.*/),
    then: _joi2.default.object().keys({})
  }).when('profile', {
    is: _joi2.default.string().regex(/^foot.*/),
    then: _joi2.default.object().keys({})
  }),
  avoid_polygons: _joi2.default.object(),
  avoidables: _joi2.default.array().when('profile', {
    is: _joi2.default.string().regex(/^driving.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['highways', 'tollways', 'ferries', 'fords'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^foot.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['steps', 'ferries', 'fords'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^cycling.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['highways', 'tollways', 'ferries'])).description('Valid avoidables for selected profile.')
  }).when('profile', {
    is: _joi2.default.string().regex(/^wheelchair.*/),
    then: _joi2.default.array().items(_joi2.default.string().valid(['steps', 'ferries'])).description('Valid avoidables for selected profile.')
  }).description('List of supported avoidables for specific profile.'),
  range_type: _joi2.default.string().valid(['time', 'distance']).default('time').description('Set time for isochrones or distance for equidistants.'),
  smoothing: _joi2.default.number().min(0).max(1),
  interval: _joi2.default.array().items(_joi2.default.number().default(60)).description('Ranges to calculate distances/durations for. This can be a list of multiple ranges, e.g. [600, 1200, 1400] or a single value list. In the latter case, you can also specify the segments variable to break the single value into more isochrones. In meters or seconds.'),
  format: _joi2.default.string().valid(['geojson']).default('geojson').description('Specifies which geometry format should be returned.'),
  range: _joi2.default.array().items(_joi2.default.number()).min(1).max(1).description('Maximum range value of the analysis in seconds for time and meters for distance. Alternatively a comma separated list of specific single range values.').default(60),
  units: _joi2.default.string().valid(['m', 'km', 'mi']).description('Specifies the units of response.'),
  area_units: _joi2.default.string().valid(['m', 'km', 'mi']).description('Specifies the area units of response.'),
  attributes: _joi2.default.array().items(_joi2.default.string().valid('area', 'reachfactor', 'total_pop')).description('List of requested attributes. area: Returns the area of each polygon in its feature properties. reachfactor: Returns a reachability score between 0 and 1. total_pop: Returns the total population of each polygon based on Global Human Settlement data.'),
  location_type: _joi2.default.string().valid(['start', 'destination']).default('start').description('Start treats the location(s) as starting point, destination as goal. '),
  options: _joi2.default.object().description('Refer to https://openrouteservice.org for detailed documentation. Construct your own dict() following the example of the minified options object. Will be converted to json automatically.'),
  service: _joi2.default.string().default('isochrones').description('Determines the service endpoint to be used.'),
  api_version: _joi2.default.string().valid(['v2']).default('v2').description('Determines the API version to be used.'),
  host: _joi2.default.string().default('https://api.openrouteservice.org').description('Determines the API url.'),
  mime_type: _joi2.default.string().valid(['application/json']).default('application/json').description('Determines the mime type of request.')
}).unknown(false);

exports.default = schema;